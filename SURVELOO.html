<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>N64 Zelda Style City - Playable Character</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #healthbar-container {
      position: fixed;
      left: 20px;
      bottom: 20px;
      width: 220px;
      height: 28px;
      background: rgba(0,0,0,0.4);
      border-radius: 8px;
      border: 2px solid #222;
      z-index: 10;
      display: flex;
      align-items: center;
      padding: 4px 10px;
      box-sizing: border-box;
    }
    #healthbar-bg {
      width: 180px;
      height: 16px;
      background: #333;
      border-radius: 6px;
      margin-right: 10px;
      overflow: hidden;
      position: relative;
    }
    #healthbar {
      height: 100%;
      background: linear-gradient(90deg, #4caf50, #aeea00);
      border-radius: 6px 0 0 6px;
      transition: width 0.2s;
    }
    #healthbar-text {
      color: #fff;
      font-family: sans-serif;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
      min-width: 32px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="healthbar-container">
    <div id="healthbar-bg">
      <div id="healthbar" style="width:100%"></div>
    </div>
    <div id="healthbar-text">100</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      70, window.innerWidth / window.innerHeight, 0.1, 1000
    );

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // --- Ground (city pavement) ---
    const groundSize = 100;
    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
    const pavementTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/brick_diffuse.jpg');
    pavementTexture.wrapS = pavementTexture.wrapT = THREE.RepeatWrapping;
    pavementTexture.repeat.set(groundSize / 8, groundSize / 8);
    const groundMaterial = new THREE.MeshLambertMaterial({ map: pavementTexture });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- City Blocks (buildings with windows and doors, some missing) ---
    function createBuilding(x, z, w, h, d, color) {
      const geo = new THREE.BoxGeometry(w, h, d);
      const mat = new THREE.MeshLambertMaterial({ color });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, h / 2, z);
      scene.add(mesh);

      // Door (front center)
      const doorGeo = new THREE.BoxGeometry(w * 0.3, h * 0.35, 0.15);
      const doorMat = new THREE.MeshLambertMaterial({ color: 0x553311 });
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(x, h * 0.175, z + d / 2 + 0.08);
      scene.add(door);

      // Windows (front face, 2 rows, 2 columns)
      const winGeo = new THREE.BoxGeometry(w * 0.22, h * 0.18, 0.08);
      const winMat = new THREE.MeshLambertMaterial({ color: 0x99d9ea, emissive: 0x222244 });
      for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 2; col++) {
          const win = new THREE.Mesh(winGeo, winMat);
          win.position.set(
            x + (col === 0 ? -w * 0.25 : w * 0.25),
            h * 0.5 + row * h * 0.22,
            z + d / 2 + 0.09
          );
          scene.add(win);
        }
      }
    }

    // Generate a grid of city blocks with streets and some empty plots
    const blockSize = 8;
    const streetWidth = 4;
    const cityBlocks = 5;
    const emptyPlots = [];
    for (let i = 0; i < cityBlocks; i++) {
      for (let j = 0; j < cityBlocks; j++) {
        if ((i === 2 && j === 2) || (Math.random() < 0.22)) {
          emptyPlots.push({i, j});
          continue;
        }
        const w = 4 + Math.random() * 3;
        const d = 4 + Math.random() * 3;
        const h = 4 + Math.random() * 10;
        const color = [0xb0b0b0, 0x8888aa, 0xaabbbb, 0xcccccc, 0x999988][Math.floor(Math.random() * 5)];
        const x = (i - cityBlocks / 2) * (blockSize + streetWidth);
        const z = (j - cityBlocks / 2) * (blockSize + streetWidth);
        createBuilding(x, z, w, h, d, color);
      }
    }

    // --- Roads (simple dark planes) ---
    for (let i = 0; i <= cityBlocks; i++) {
      const roadGeo = new THREE.PlaneGeometry(streetWidth, cityBlocks * (blockSize + streetWidth));
      const roadMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const road = new THREE.Mesh(roadGeo, roadMat);
      road.rotation.x = -Math.PI / 2;
      road.position.x = (i - cityBlocks / 2 - 0.5) * (blockSize + streetWidth);
      road.position.y = 0.01;
      scene.add(road);

      const roadGeo2 = new THREE.PlaneGeometry(cityBlocks * (blockSize + streetWidth), streetWidth);
      const road2 = new THREE.Mesh(roadGeo2, roadMat);
      road2.rotation.x = -Math.PI / 2;
      road2.position.z = (i - cityBlocks / 2 - 0.5) * (blockSize + streetWidth);
      road2.position.y = 0.01;
      scene.add(road2);
    }

    // --- Street Lights ---
    function createStreetLight(x, z) {
      const poleGeo = new THREE.CylinderGeometry(0.12, 0.16, 2.8, 6);
      const poleMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.set(x, 1.4, z);

      const lampGeo = new THREE.SphereGeometry(0.22, 8, 8);
      const lampMat = new THREE.MeshLambertMaterial({ color: 0xffffcc, emissive: 0xffff99 });
      const lamp = new THREE.Mesh(lampGeo, lampMat);
      lamp.position.set(x, 2.7, z);

      const light = new THREE.PointLight(0xffffcc, 0.7, 8);
      light.position.set(x, 2.7, z);

      scene.add(pole, lamp, light);
    }
    for (let i = 0; i <= cityBlocks; i++) {
      for (let j = 0; j <= cityBlocks; j++) {
        const x = (i - cityBlocks / 2 - 0.5) * (blockSize + streetWidth);
        const z = (j - cityBlocks / 2 - 0.5) * (blockSize + streetWidth);
        createStreetLight(x + streetWidth / 2, z + streetWidth / 2);
      }
    }

    // --- Trees in parks (empty plots) ---
    function createTree(x, z) {
      const trunkGeo = new THREE.CylinderGeometry(0.18, 0.22, 1.2, 6);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x7a4f1d });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(x, 0.6, z);

      const foliageGeo = new THREE.SphereGeometry(0.7, 8, 8);
      const foliageMat = new THREE.MeshLambertMaterial({ color: 0x2e8b57 });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.set(x, 1.5, z);

      scene.add(trunk, foliage);
    }
    emptyPlots.forEach(({i, j}) => {
      const x = (i - cityBlocks / 2) * (blockSize + streetWidth);
      const z = (j - cityBlocks / 2) * (blockSize + streetWidth);
      for (let t = 0; t < 3; t++) {
        const tx = x + (Math.random() - 0.5) * blockSize * 0.7;
        const tz = z + (Math.random() - 0.5) * blockSize * 0.7;
        createTree(tx, tz);
      }
    });

    // --- Playable Character (Improved Roblox style, scaled down) ---
    function createRobloxCharacter() {
      const group = new THREE.Group();

      // Torso (blue)
      const torsoGeo = new THREE.BoxGeometry(0.5, 0.6, 0.25);
      const torsoMat = new THREE.MeshLambertMaterial({ color: 0x1e90ff });
      const torso = new THREE.Mesh(torsoGeo, torsoMat);
      torso.position.set(0, 0.6 / 2 + 0.5, 0);
      group.add(torso);

      // Head (yellow, with face)
      const headGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
      const headMat = new THREE.MeshLambertMaterial({ color: 0xffe550 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 0.6 + 0.175 + 0.5, 0);

      // Face (simple smile and eyes)
      const faceCanvas = document.createElement('canvas');
      faceCanvas.width = 128;
      faceCanvas.height = 128;
      const ctx = faceCanvas.getContext('2d');
      ctx.fillStyle = "#ffe550";
      ctx.fillRect(0, 0, 128, 128);
      ctx.fillStyle = "#222";
      ctx.beginPath(); // left eye
      ctx.arc(44, 54, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath(); // right eye
      ctx.arc(84, 54, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.beginPath(); // smile
      ctx.arc(64, 80, 22, 0.15 * Math.PI, 0.85 * Math.PI);
      ctx.stroke();
      const faceTex = new THREE.CanvasTexture(faceCanvas);
      const faceMat = [
        headMat, headMat, headMat, headMat,
        new THREE.MeshLambertMaterial({ map: faceTex }),
        headMat
      ];
      const headWithFace = new THREE.Mesh(headGeo, faceMat);
      headWithFace.position.copy(head.position);
      group.add(headWithFace);

      // Left Arm (tan)
      const armGeo = new THREE.BoxGeometry(0.2, 0.55, 0.2);
      const armMat = new THREE.MeshLambertMaterial({ color: 0xffe0b3 });
      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.position.set(-0.35, 0.6 / 2 + 0.5, 0);
      group.add(leftArm);

      // Right Arm (tan)
      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.position.set(0.35, 0.6 / 2 + 0.5, 0);
      group.add(rightArm);

      // Left Leg (green)
      const legGeo = new THREE.BoxGeometry(0.225, 0.6, 0.225);
      const legMat = new THREE.MeshLambertMaterial({ color: 0x3cb371 });
      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.125, 0.3, 0);
      group.add(leftLeg);

      // Right Leg (green)
      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.125, 0.3, 0);
      group.add(rightLeg);

      return group;
    }

    const character = createRobloxCharacter();
    character.position.set(0, 0, 0);
    scene.add(character);

    // --- Zombie Cubes ---
    const zombies = [];
    const zombieSize = 0.35; // same as head size
    const zombieGeo = new THREE.BoxGeometry(zombieSize, zombieSize, zombieSize);
    const zombieMat = new THREE.MeshLambertMaterial({ color: 0x4caf50, emissive: 0x225522 });
    function spawnZombie(x, z) {
      const zombie = new THREE.Mesh(zombieGeo, zombieMat.clone());
      zombie.position.set(x, zombieSize / 2, z);
      scene.add(zombie);
      zombies.push(zombie);
    }
    // Spawn 8 zombies at random locations
    for (let i = 0; i < 8; i++) {
      let zx = (Math.random() - 0.5) * groundSize * 0.8;
      let zz = (Math.random() - 0.5) * groundSize * 0.8;
      spawnZombie(zx, zz);
    }

    // --- Health Bar ---
    let health = 100;
    const healthBar = document.getElementById('healthbar');
    const healthText = document.getElementById('healthbar-text');
    function setHealth(val) {
      health = Math.max(0, Math.min(100, val));
      healthBar.style.width = health + "%";
      healthText.textContent = Math.round(health);
    }

    // --- Controls ---
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let onGround = true;

    // Camera orbit variables
    let camOrbitAngle = 0;
    let camOrbitRadius = 5;
    let camOrbitHeight = 2.5;
    let camOrbitPitch = 0.2;
    let isMouseDown = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Keyboard controls
    document.addEventListener('keydown', function(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = true; break;
        case 'ArrowLeft':
        case 'KeyA': moveLeft = true; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = true; break;
        case 'ArrowRight':
        case 'KeyD': moveRight = true; break;
        case 'Space':
          if (onGround) {
            velocity.y = 0.18;
            onGround = false;
          }
          break;
      }
    });
    document.addEventListener('keyup', function(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW': moveForward = false; break;
        case 'ArrowLeft':
        case 'KeyA': moveLeft = false; break;
        case 'ArrowDown':
        case 'KeyS': moveBackward = false; break;
        case 'ArrowRight':
        case 'KeyD': moveRight = false; break;
      }
    });

    // Mouse drag to orbit camera (horizontal and vertical, INVERTED Y)
    renderer.domElement.addEventListener('mousedown', function(e) {
      isMouseDown = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    renderer.domElement.addEventListener('mouseup', function() {
      isMouseDown = false;
    });
    renderer.domElement.addEventListener('mousemove', function(e) {
      if (isMouseDown) {
        camOrbitAngle -= (e.clientX - lastMouseX) * 0.01;
        camOrbitPitch += (e.clientY - lastMouseY) * 0.01; // INVERTED
        camOrbitPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, camOrbitPitch));
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
    });

    // --- Zombie Spawning (disabled for now) ---
    // function spawnZombieAtRandomInterval() {
    //   const interval = 1000 + Math.random() * 9000;
    //   setTimeout(() => {
    //     let zx = (Math.random() - 0.5) * groundSize * 0.8;
    //     let zz = (Math.random() - 0.5) * groundSize * 0.8;
    //     spawnZombie(zx, zz);
    //     spawnZombieAtRandomInterval();
    //   }, interval);
    // }
    // spawnZombieAtRandomInterval();

    // --- Animate ---
    function animate() {
      requestAnimationFrame(animate);

      // Movement direction is based on where the character is facing
      direction.set(0, 0, 0);
      if (moveForward) direction.z -= 1;
      if (moveBackward) direction.z += 1;
      if (moveLeft) direction.x -= 1;
      if (moveRight) direction.x += 1;
      direction.normalize();

      // Only rotate if moving
      if (direction.length() > 0) {
        const moveAngle = Math.atan2(direction.x, direction.z);
        character.rotation.y = moveAngle + camOrbitAngle;
      }

      // Move character in the direction it is facing
      const moveSpeed = 0.08;
      if (direction.length() > 0) {
        const angle = character.rotation.y;
        const forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
        character.position.x += forward.x * moveSpeed * direction.length();
        character.position.z += forward.z * moveSpeed * direction.length();
      }

      // Gravity and jumping
      velocity.y -= 0.009; // gravity
      character.position.y += velocity.y;
      if (character.position.y < 0) {
        velocity.y = 0;
        character.position.y = 0;
        onGround = true;
      }

      // Zombies chase the player
      zombies.forEach(zombie => {
        const dx = character.position.x - zombie.position.x;
        const dz = character.position.z - zombie.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist > 0.01) {
          const speed = 0.018;
          zombie.position.x += (dx / dist) * speed;
          zombie.position.z += (dz / dist) * speed;
        }
        // Damage player if close
        if (dist < zombieSize * 0.9 && character.position.y < 0.2) {
          setHealth(health - 0.25);
        }
      });

      // Camera orbits around character (with pitch)
      const camY = Math.sin(camOrbitPitch) * camOrbitRadius;
      const camXZ = Math.cos(camOrbitPitch) * camOrbitRadius;
      camera.position.x = character.position.x + Math.sin(camOrbitAngle) * camXZ;
      camera.position.z = character.position.z + Math.cos(camOrbitAngle) * camXZ;
      camera.position.y = character.position.y + camOrbitHeight + camY;
      camera.lookAt(character.position.x, character.position.y + 0.6, character.position.z);

      renderer.render(scene, camera);
    }
    animate();

    // --- Responsive resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
  <div style="position:fixed;top:10px;left:10px;color:#fff;font-family:sans-serif;background:rgba(0,0,0,0.3);padding:8px 12px;border-radius:8px;">
    <b>Controls:</b><br>
    Move: WASD / Arrow Keys<br>
    Jump: Space<br>
    Orbit Camera: Drag Mouse (up/down/left/right, Y is inverted)
  </div>
</body>
</html>